<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>async-await on Atishay Jain</title><link>https://atishay.me/tags/async-await/</link><description>Recent content in async-await on Atishay Jain</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>contact@atishay.me (Atishay Jain)</managingEditor><webMaster>contact@atishay.me (Atishay Jain)</webMaster><lastBuildDate>Thu, 21 Mar 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://atishay.me/tags/async-await/index.xml" rel="self" type="application/rss+xml"/><item><title>Shared data with Async Await - Part II</title><link>https://atishay.me/blog/2019/03/21/shared-data-with-async-await-part-ii/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><author>contact@atishay.me (Atishay Jain)</author><guid>https://atishay.me/blog/2019/03/21/shared-data-with-async-await-part-ii/</guid><description>In the previous post we discussed the shared data problem and the needs for locks in JS code if we are dealing with APIs that have state in them and we do not have the ability to get general purpose high-level stateless APIs.
Reader-Writer Problem One extension to this problem with is more complicated and also requires a more complicated solution is the reader writer problem. To understand it, lets look at the scene from the movie Despicable Me.</description></item><item><title>Shared data with Async Await - Part I</title><link>https://atishay.me/blog/2019/03/20/shared-data-with-async-await-part-i/</link><pubDate>Wed, 20 Mar 2019 10:00:00 +0000</pubDate><author>contact@atishay.me (Atishay Jain)</author><guid>https://atishay.me/blog/2019/03/20/shared-data-with-async-await-part-i/</guid><description>While JavaScript has strong support for asynchronous code, we rarely encounter issues related to asynchronous code as frontend developers. As soon we move to doing some back-end, we realize the inherent complexities of asynchronous programming.
The shared data problem One of the most important problems in asynchronous programming is the shared data or the critical region problem. To understand this problem have a look at the following figure:
Shared Data Problem In this figure we have stateful APIs from the data store with the basic access to read and write but no in-built transaction support.</description></item><item><title>Method wrappers in Async Await - Part III</title><link>https://atishay.me/blog/2019/03/20/method-wrappers-in-async-await-part-iii/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><author>contact@atishay.me (Atishay Jain)</author><guid>https://atishay.me/blog/2019/03/20/method-wrappers-in-async-await-part-iii/</guid><description>In the previous post we used memoize to prevent the parallel calls to a function. In this post we will be extending the memoize implementation to handle more of the situations that may arise with asynchronous functions and extending memoize to handle those additional cases.
Here is the memoize function from lodash.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 function memoize(func, resolver) { const memoized = function(.</description></item><item><title>Method wrappers in Async Await - Part II</title><link>https://atishay.me/blog/2019/03/19/method-wrappers-in-async-await-part-ii/</link><pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate><author>contact@atishay.me (Atishay Jain)</author><guid>https://atishay.me/blog/2019/03/19/method-wrappers-in-async-await-part-ii/</guid><description>In the previous post we discussed about creating wrappers over asynchronous methods to provide some extra functionality. In this post we will be discussing creating a more complicated wrapper that uses the promises that the async function returns to solve a very common parallel calls problem.
Parallel calls problem The parallel calls problem is a very common problem in software development. Suppose you have an asynchronous method get that gets the data from the server.</description></item><item><title>Method wrappers in Async Await - Part I</title><link>https://atishay.me/blog/2019/03/16/method-wrappers-in-async-await-part-i/</link><pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate><author>contact@atishay.me (Atishay Jain)</author><guid>https://atishay.me/blog/2019/03/16/method-wrappers-in-async-await-part-i/</guid><description>Wrapping methods is not very common in day to day programming but it is a very useful concept. We could abstract out shared functionality over methods with a defined signature in a wrapper and not have to repeat the same tasks again and again. The semantics of methods having return values that need to be returned sometime makes regular use cases of calling methods without wrappers cumbersome. In the world of JavaScript, methods like debounce and throttle have been popular since the very beginning of the programming language.</description></item><item><title>Snippets for success with Async Await</title><link>https://atishay.me/blog/2019/03/14/snippets-for-success-with-async-await/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><author>contact@atishay.me (Atishay Jain)</author><guid>https://atishay.me/blog/2019/03/14/snippets-for-success-with-async-await/</guid><description>The async-await feature in modern JavaScript is very powerful and can provide a lot of functionality with very little code. The more we get into using async-await, the more we realize that it is not just syntactic sugar, it is a way of thinking. The more we use async await, the more we feel liberated and empowered. Here are some of the snippets in the order of increasing develop power and productivity and not necessarily the increase in code size.</description></item><item><title>Understanding the event driven nature of Node.js</title><link>https://atishay.me/blog/2019/03/13/understanding-the-event-driven-nature-of-node.js/</link><pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate><author>contact@atishay.me (Atishay Jain)</author><guid>https://atishay.me/blog/2019/03/13/understanding-the-event-driven-nature-of-node.js/</guid><description>Fundamental Operators To understand at the fundamental level how the event driven mechanism in node.js works, lets start with the fundamental design of the computer and understand how the computer works. Still looking at the very high level and ignoring the magic that the OS provides, there is something called the instruction pointer in the CPU. This points to the next instruction in the assembly language that is executed. All programming languages eventually go down to assembly as that is what the hardware understands.</description></item><item><title>From callbacks to async - await</title><link>https://atishay.me/blog/2018/08/25/from-callbacks-to-async-await/</link><pubDate>Sat, 25 Aug 2018 00:00:00 +0000</pubDate><author>contact@atishay.me (Atishay Jain)</author><guid>https://atishay.me/blog/2018/08/25/from-callbacks-to-async-await/</guid><description>From callbacks to async - await - A migration guide I originally wrote this article for Morning Cup of Coding. Morning Cup of Coding is a newsletter for software engineers to be up to date with and learn something new from all fields of programming. Curated by Pek and delivered every day, it is designed to be your morning reading list. Learn more.
Callbacks have been at the core of JavaScript and Node.</description></item></channel></rss>